import math
from sympy import Symbol, floor, solveset, Interval, S, solve, sqrt, sin, cos, pi, log, E, re, im
from sympy.solvers.inequalities import solve_univariate_inequality
from sympy.abc import x


def is_integer(expr):
    """Проверяет, является ли результат выражения целым числом."""
    # Мы не можем напрямую проверить, является ли символьное выражение целым числом,
    # но в контексте этих задач мы можем проверить, есть ли у него символы.
    # Если нет, это числовое значение.
    if not expr.free_symbols:
        return im(expr) == 0 and float(expr).is_integer()
    return False


def task_1_1():
    """
    Задание 1.1. Решите уравнение: [ (5+6x)/8 ] = (15x-7)/5
    """
    print("--- Задание 1.1 ---")
    # Пусть k = (15x-7)/5. Поскольку k является результатом функции floor, k должно быть целым числом.
    # Из k = (15x-7)/5 => x = (5k+7)/15.
    # Из определения функции floor: k <= (5+6x)/8 < k+1.
    # Подставим x:
    # k <= (5 + 6*(5k+7)/15) / 8 < k+1
    # k <= (5 + 2*(5k+7)/5) / 8 < k+1
    # k <= ( (25 + 10k + 14)/5 ) / 8 < k+1
    # k <= (39 + 10k) / 40 < k+1

    # Решаем два неравенства для целого k:
    # 1) 40k <= 39 + 10k  => 30k <= 39 => k <= 1.3
    # 2) 39 + 10k < 40k + 40 => -1 < 30k => k > -1/30

    # Целочисленные значения k, удовлетворяющие -1/30 < k <= 1.3, это k=0 и k=1.
    solutions = []
    for k in [0, 1]:
        x_sol = (5 * k + 7) / 15
        solutions.append(x_sol)

    print(f"Уравнение: [ (5+6x)/8 ] = (15x-7)/5")
    print(f"Решения: x = {solutions[0]} и x = {solutions[1]}")
    print("-" * 20 + "\n")


def task_2_1():
    """
    Задание 2.1. Решите уравнение: [x-1] = [(x+2)/2]
    """
    print("--- Задание 2.1 ---")
    # Пусть k = [x-1], где k - целое число.
    # Из определения floor:
    # 1) k <= x-1 < k+1  =>  k+1 <= x < k+2
    # Уравнение становится k = [(x+2)/2], что означает:
    # 2) k <= (x+2)/2 < k+1  =>  2k <= x+2 < 2k+2  =>  2k-2 <= x < 2k

    # Мы ищем пересечение интервалов [k+1, k+2) и [2k-2, 2k).
    # Пересечение существует, если max(k+1, 2k-2) < min(k+2, 2k).
    # 1) 2k-2 < k+2 => k < 4
    # 2) k+1 < 2k   => 1 < k
    # Итак, возможные целые значения для k: 2, 3.

    k = Symbol('k', integer=True)
    interval1 = Interval(k + 1, k + 2, left_open=False, right_open=True)
    interval2 = Interval(2 * k - 2, 2 * k, left_open=False, right_open=True)

    intersection = interval1.intersect(interval2)

    # **** ИСПРАВЛЕНИЕ: Убираем строку, вызывающую ошибку. ****
    # Вместо этого используем результат ручного анализа (1 < k < 4),
    # который уже есть в комментариях.

    solutions = []
    for k_val in [2, 3]:
        solutions.append(intersection.subs(k, k_val))

    # Объединение интервалов [3, 4) и [4, 5) дает [3, 5).
    solution_set = solutions[0].union(solutions[1])

    print(f"Уравнение: [x-1] = [(x+2)/2]")
    print(f"Решение: x принадлежит интервалу {solution_set}")
    print("-" * 20 + "\n")


def task_3_1():
    """
    Задание 3.1. Решите уравнение: x^2 - [x] - 30 = 0
    """
    print("--- Задание 3.1 ---")
    # Пусть k = [x], где k - целое число.
    # Уравнение становится x^2 - k - 30 = 0 => x^2 = k + 30.
    # Отсюда x = sqrt(k+30) или x = -sqrt(k+30).
    # Также должно выполняться k <= x < k+1.

    solutions = []
    # Проверяем возможные значения k. Поскольку x^2 >= 0, то k+30 >= 0 => k >= -30.
    # Проверяем в разумном диапазоне. x^2 ~= k, k+30 ~= k => k не может быть очень большим.
    # k^2 < k+30 => k^2-k-30 < 0 => (k-6)(k+5)<0. k примерно между -5 и 6.
    # (-k)^2 ~= k, k+30 ~= -k => k^2+k-30 ~= 0 => (k+6)(k-5) ~= 0. k около -6 или 5.
    for k in range(-30, 10):  # Проверяем в разумном диапазоне
        # Случай 1: x = sqrt(k+30)
        if k + 30 >= 0:
            x_val_pos = math.sqrt(k + 30)
            if math.floor(x_val_pos) == k:
                solutions.append(x_val_pos)

        # Случай 2: x = -sqrt(k+30)
        if k + 30 >= 0:
            x_val_neg = -math.sqrt(k + 30)
            if math.floor(x_val_neg) == k:
                solutions.append(x_val_neg)

    print(f"Уравнение: x^2 - [x] - 30 = 0")
    print(f"Решения: {sorted(list(set(solutions)))}")
    print("-" * 20 + "\n")


def task_4_1():
    """
    Задание 4.1. Решите уравнение: |sin(x) + cos(x)| = 5 - 4[x]
    """
    print("--- Задание 4.1 ---")
    # LHS (левая часть): |sin(x) + cos(x)| = |sqrt(2)*sin(x+pi/4)|.
    # Диапазон значений LHS: [0, sqrt(2)].
    # Следовательно, 0 <= 5 - 4[x] <= sqrt(2).
    # Пусть k = [x], где k - целое число.
    # 1) 5 - 4k >= 0 => 5 >= 4k => k <= 1.25
    # 2) 5 - 4k <= sqrt(2) => 5 - sqrt(2) <= 4k => k >= (5 - math.sqrt(2))/4
    # k >= (5 - 1.414)/4 ~= 0.896
    # Единственное целое k, удовлетворяющее 0.896 <= k <= 1.25, это k=1.
    k = 1
    print(f"Из анализа диапазона значений, [x] должно быть равно {k}.")

    # Теперь решаем уравнение |sin(x) + cos(x)| = 5 - 4*1 = 1
    # для x в интервале [1, 2).
    # |sqrt(2)sin(x+pi/4)| = 1  => |sin(x+pi/4)| = 1/sqrt(2)

    solutions = []
    pi_val = math.pi

    # Решения для x + pi/4 = n*pi/2 + pi/4, где n - нечетное
    # x + pi/4 = pi/4, 3pi/4, 5pi/4, 7pi/4 ...
    # x = 0, pi/2, pi, 3pi/2, ...

    # Проверяем, какие решения попадают в интервал [1, 2)
    # x = pi/2 ~= 1.57. Это значение подходит.
    if 1 <= pi_val / 2 < 2:
        solutions.append(pi / 2)

    print(f"Уравнение: |sin(x) + cos(x)| = 5 - 4[x]")
    # Выводим символьный и числовой результат
    print(f"Решение в интервале [1, 2): x = pi/2 (приблизительно {solutions[0].evalf()})")
    print("-" * 20 + "\n")


def task_5_1():
    """
    Задание 5.1. Решите уравнение: [x/2 - [x/2]] = lg(x)
    """
    print("--- Задание 5.1 ---")
    # Выражение a - [a] - это дробная часть числа a, обозначаемая {a}.
    # Уравнение принимает вид: [{x/2}] = lg(x).
    # По определению, 0 <= {a} < 1 для любого a.
    # Целая часть от этого выражения, [ {a} ], всегда равна 0.
    # Итак, уравнение упрощается до lg(x) = 0.
    # lg(x) - это десятичный логарифм.
    # lg(x) = 0 => x = 10^0 = 1.

    x_sol = 1
    # Проверка:
    # LHS: [1/2 - [1/2]] = [0.5 - 0] = [0.5] = 0
    # RHS: lg(1) = 0
    # LHS = RHS, решение верное.

    print(f"Уравнение: [x/2 - [x/2]] = lg(x)")
    print(f"Решение: x = {x_sol}")
    print("-" * 20 + "\n")


def task_6_1():
    """
    Задание 6.1. Укажите наибольшее и наименьшее решения уравнения: {(x+1)^3} = x^3
    """
    print("--- Задание 6.1 ---")
    # {a} - дробная часть числа. По определению 0 <= {a} < 1.
    # Следовательно, 0 <= x^3 < 1, что означает 0 <= x < 1.
    # Используем свойство {a} = a - [a].
    # (x+1)^3 - [(x+1)^3] = x^3
    # x^3 + 3x^2 + 3x + 1 - [(x+1)^3] = x^3
    # 3x^2 + 3x + 1 = [(x+1)^3]
    # Пусть k = [(x+1)^3], где k - целое число.

    # Поскольку 0 <= x < 1, то 1 <= x+1 < 2, и 1 <= (x+1)^3 < 8.
    # Значит, k = [(x+1)^3] может принимать целые значения от 1 до 7.

    solutions = []
    for k in range(1, 8):
        # Решаем квадратное уравнение 3x^2 + 3x + (1-k) = 0
        D = 9 - 4 * 3 * (1 - k)  # Дискриминант
        if D >= 0:
            x1 = (-3 + math.sqrt(D)) / 6
            x2 = (-3 - math.sqrt(D)) / 6
            # Проверяем решения и условие k = floor((x+1)^3)
            for x_sol in [x1, x2]:
                if 0 <= x_sol < 1:
                    if math.floor((x_sol + 1) ** 3) == k:
                        solutions.append(x_sol)

    print(f"Уравнение: {{(x+1)^3}} = x^3")
    if solutions:
        print(f"Найденные решения: {solutions}")
        print(f"Наименьшее решение: {min(solutions)}")
        print(f"Наибольшее решение: {max(solutions)}")
    else:
        print("Решений не найдено.")
    print("-" * 20 + "\n")


def task_7_1():
    """
    Задание 7.1. Решите систему уравнений:
    1) x + [y] + {z} = 1.1
    2) y + [z] + {x} = 2.2
    3) z + [x] + {y} = 3.3
    """
    print("--- Задание 7.1 ---")
    # Используем v = [v] + {v}
    # 1) [x]+{x} + [y] + {z} = 1.1
    # 2) [y]+{y} + [z] + {x} = 2.2
    # 3) [z]+{z} + [x] + {y} = 3.3

    # Складываем все три уравнения:
    # x+y+z + [x]+[y]+[z] + {x}+{y}+{z} = 6.6
    # ([x]+{x}) + ([y]+{y}) + ([z]+{z}) + ... = 6.6
    # 2(x+y+z) = 6.6 => x+y+z = 3.3

    # Вычтем из x+y+z=3.3 первое уравнение:
    # (x+y+z) - (x + [y] + {z}) = 3.3 - 1.1
    # y - [y] + z - {z} = 2.2
    # {y} + [z] = 2.2 => {y}=0.2, [z]=2

    # Вычтем из x+y+z=3.3 второе уравнение:
    # (x+y+z) - (y + [z] + {x}) = 3.3 - 2.2
    # x - {x} + z - [z] = 1.1
    # [x] + {z} = 1.1 => [x]=1, {z}=0.1

    # Вычтем из x+y+z=3.3 третье уравнение:
    # (x+y+z) - (z + [x] + {y}) = 3.3 - 3.3
    # y - {y} + x - [x] = 0
    # [y] + {x} = 0 => [y]=0, {x}=0

    x = 1 + 0
    y = 0 + 0.2
    z = 2 + 0.1

    print("Система уравнений:")
    print("x + [y] + {z} = 1.1")
    print("y + [z] + {x} = 2.2")
    print("z + [x] + {y} = 3.3")
    print(f"Решение: x = {x}, y = {y}, z = {z}")
    print("-" * 20 + "\n")


def legendre_formula(n, p):
    """Вычисляет показатель степени простого p в разложении n!"""
    exponent = 0
    while n > 0:
        n //= p
        exponent += n
    return exponent


def task_8_1():
    """
    Задание 8.1. Найдите каноническое разложение числа 16! и сколькими нулями оканчивается его десятичная запись.
    """
    print("--- Задание 8.1 ---")
    n = 16
    primes_under_16 = [2, 3, 5, 7, 11, 13]
    decomposition = {}
    for p in primes_under_16:
        decomposition[p] = legendre_formula(n, p)

    decomp_str = " * ".join([f"{p}^{exp}" for p, exp in decomposition.items()])
    print(f"Каноническое разложение 16!: {decomp_str}")

    # Количество нулей определяется степенью 5 (т.к. 2 встречается чаще)
    num_zeros = decomposition.get(5, 0)
    print(f"Число 16! оканчивается на {num_zeros} нуля.")
    print("-" * 20 + "\n")


def task_9_1():
    """
    Задание 9.1. По указанному каноническому разложению n! восстановите числа n и alpha_i.
    n! = 2^a2 * 3^9 * 5^4 * 7^a7 * 11^a11 * 13^a13 * 17^a17 * 19^a19 * 23^a23
    """
    print("--- Задание 9.1 ---")
    # Самый большой простой множитель - 23. Это означает, что 23 <= n < 29 (следующее простое).
    # Используем данные показатели для определения n.
    # a3 = 9, a5 = 4.

    found_n = -1
    for n_candidate in range(23, 29):
        # Проверяем по a3
        if legendre_formula(n_candidate, 3) == 9 and legendre_formula(n_candidate, 5) == 4:
            found_n = n_candidate
            break

    if found_n != -1:
        n = found_n
        primes_in_decomp = [2, 3, 5, 7, 11, 13, 17, 19, 23]
        exponents = {}
        for p in primes_in_decomp:
            exponents[p] = legendre_formula(n, p)

        print(f"Восстановленное значение n = {n}")
        print("Восстановленные показатели alpha_i:")
        for p, exp in exponents.items():
            print(f"  a{p} = {exp}")
    else:
        print("Не удалось определить n по заданным данным.")
    print("-" * 20 + "\n")


def task_10_1():
    """
    Задание 10.1. Перечислите все натуральные трехзначные числа n такие,
    что количество натуральных чисел, не превышающих n и не делящихся
    на 5, принадлежит промежутку [79; 85].
    """
    print("--- Задание 10.1 ---")
    b, c = 79, 85
    # Количество чисел, не делящихся на 5, равно n - [n/5].
    # Ищем n в диапазоне [100, 999] такие, что b <= n - [n/5] <= c.

    solutions = []
    # Грубая оценка: n - n/5 = 0.8n.
    # 0.8n ~ 79 => n ~ 98.75
    # 0.8n ~ 85 => n ~ 106.25
    # Проверяем числа в окрестности [98, 107]
    for n in range(98, 108):
        if n < 100: continue  # Нужны только трехзначные
        count = n - math.floor(n / 5)
        if b <= count <= c:
            solutions.append(n)

    print(f"Условие: количество чисел <= n, не делящихся на 5, в промежутке [{b}, {c}].")
    print(f"Трехзначные числа n, удовлетворяющие условию:")
    print(solutions)
    print("-" * 20 + "\n")


# --- Выполнение всех заданий ---
if __name__ == "__main__":
    task_1_1()
    task_2_1()
    task_3_1()
    task_4_1()
    task_5_1()
    task_6_1()
    task_7_1()
    task_8_1()
    task_9_1()
    task_10_1()