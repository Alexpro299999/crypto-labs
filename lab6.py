# -*- coding: utf-8 -*-

def solve_task1(p, g, a, b):
    """
    Решает Задание 1: Вычисление общего секретного ключа по алгоритму Диффи-Хеллмана.
    """
    print("--- Задание 1: Алгоритм Диффи-Хеллмана ---")
    print(f"Параметры: p = {p}, g = {g}, a (ключ Алисы) = {a}, b (ключ Боба) = {b}")

    # Алиса вычисляет A = g^a mod p
    A = pow(g, a, p)
    print(f"Алиса вычисляет A = {g}^{a} mod {p} = {A} и отправляет Бобу.")

    # Боб вычисляет B = g^b mod p
    B = pow(g, b, p)
    print(f"Боб вычисляет B = {g}^{b} mod {p} = {B} и отправляет Алисе.")

    # Алиса вычисляет секретный ключ K = B^a mod p
    K_alice = pow(B, a, p)

    # Боб вычисляет секретный ключ K = A^b mod p
    K_bob = pow(A, b, p)

    print(f"Алиса вычисляет секретный ключ: K = B^a mod p = {B}^{a} mod {p} = {K_alice}")
    print(f"Боб вычисляет секретный ключ: K = A^b mod p = {A}^{b} mod {p} = {K_bob}")

    if K_alice == K_bob:
        print(f"\nОтвет: Общий секретный ключ K = {K_alice}\n")
    else:
        print("Ошибка: ключи не совпадают!\n")


def solve_task2(p, g, a, K):
    """
    Решает Задание 2: Нахождение секретного ключа Боба 'b'.
    """
    print("--- Задание 2: Нахождение ключа Боба ---")
    print(f"Параметры: p = {p}, g = {g}, a (ключ Алисы) = {a}, K (итоговый ключ) = {K}")

    # Алиса вычисляет A = g^a mod p
    A = pow(g, a, p)
    print(f"Открытый ключ Алисы A = {g}^{a} mod {p} = {A}.")

    found_b = -1
    # Мы ищем 'b' такое, что K = A^b mod p. Перебираем возможные значения b.
    for b in range(1, p):
        if pow(A, b, p) == K:
            found_b = b
            break

    if found_b != -1:
        print(f"Проверяем b = {found_b}: {A}^{found_b} mod {p} = {pow(A, found_b, p)}. Это соответствует K.")
        print(f"\nОтвет: Секретный ключ Боба b = {found_b}\n")
    else:
        print("\nОтвет: Ключ 'b' не найден в диапазоне [1, p-1].\n")


def solve_task3(full_name):
    """
    Решает Задание 3: Шифрование ФИО с помощью шифра "Королевская арка".
    """
    print("--- Задание 3: Шифр 'Королевская арка' ---")
    print(f"ФИО для шифрования: {full_name}")
    print("Описание шифра: Каждой букве соответствует фигура. Если буква вторая в паре, к фигуре добавляется точка.\n")

    # Словарь, сопоставляющий буквы с их символами и положением в паре
    cipher_map = {
        'А': ('Форма L', 'без точки'), 'Б': ('Форма L', 'с точкой'),
        'В': ('Форма V', 'без точки'), 'Г': ('Форма V', 'с точкой'),
        'Д': ('Форма >', 'без точки'), 'Е': ('Форма >', 'с точкой'),
        'Ё': ('Форма ^', 'без точки'), 'Ж': ('Форма ^', 'с точкой'),
        'З': ('Форма <', 'без точки'), 'И': ('Форма <', 'с точкой'),
        'Й': ('Форма _|', 'без точки'), 'К': ('Форма _|', 'с точкой'),
        'Л': ('Форма |_', 'без точки'), 'М': ('Форма |_', 'с точкой'),
        'Н': ('Форма П', 'без точки'), 'О': ('Форма П', 'с точкой'),
        'П': ('Форма |_|', 'без точки'), 'Р': ('Форма |_|', 'с точкой'),
        'С': ('Форма [ ] без левой стороны', 'без точки'), 'Т': ('Форма [ ] без левой стороны', 'с точкой'),
        'У': ('Форма V (перевернутая)', 'без точки'), 'Ф': ('Форма V (перевернутая)', 'с точкой'),
        'Х': ('Центр креста (X)', 'без точки'), 'Ц': ('Центр креста (X)', 'с точкой'),
        'Ч': ('Форма /', 'без точки'), 'Ш': ('Форма /', 'с точкой'),
        'Щ': ('Форма \\', 'без точки'), 'Ъ': ('Форма \\', 'с точкой'),
        'Ы': ('Форма )', 'без точки'), 'Ь': ('Форма )', 'с точкой'),
        'Э': ('Форма (', 'без точки'), 'Ю': ('Форма (', 'с точкой'),
        'Я': ('Форма _', 'без точки'),
    }

    encrypted_message = []

    # Убираем пробелы и приводим к верхнему регистру
    name_to_encrypt = full_name.replace(" ", "").upper()

    print("Результат шифрования:")
    for char in name_to_encrypt:
        if char in cipher_map:
            shape, dot_status = cipher_map[char]
            print(f"Буква '{char}': {shape}, {dot_status}")
        else:
            print(f"Символ '{char}' не найден в алфавите шифра.")
    print("\n")


def solve_task4(a, b, c):
    """
    Решает Задание 4: Решение диофантова уравнения ax + by = c в полях Z_11 и Z_13.
    """
    print("--- Задание 4: Решение диофантовых уравнений ---")
    print(f"Уравнение: {a}x + {b}y = {c}")

    # --- Часть 1: Решение в поле Z_11 ---
    m11 = 11
    print(f"\nРешаем в поле Z_{m11}: {a}x + {b}y ≡ {c} (mod {m11})")

    try:
        # y ≡ (c - ax) * b_inv (mod 11)
        b_inv_11 = pow(b, -1, m11)
        print(f"Обратный элемент для {b} mod {m11} это {b_inv_11}.")

        solutions_11 = []
        for x in range(m11):
            # y = (c - a*x) * b_inv
            y = ((c - a * x) * b_inv_11) % m11
            solutions_11.append((x, y))

        print("Ответ: Множество пар (x, y):")
        print(solutions_11)

    except ValueError:
        print(f"Решений нет, так как у {b} нет обратного элемента по модулю {m11}.")

    # --- Часть 2: Решение в поле Z_13 ---
    m13 = 13
    print(f"\nРешаем в поле Z_{m13}: {a}x + {b}y ≡ {c} (mod {m13})")

    try:
        # x ≡ (c - by) * a_inv (mod 13)
        a_inv_13 = pow(a, -1, m13)
        print(f"Обратный элемент для {a} mod {m13} это {a_inv_13}.")

        solutions_13 = []
        for y in range(m13):
            # x = (c - b*y) * a_inv
            x = ((c - b * y) * a_inv_13) % m13
            solutions_13.append((x, y))

        print("Ответ: Множество пар (x, y):")
        print(solutions_13)

    except ValueError:
        print(f"Решений нет, так как у {a} нет обратного элемента по модулю {m13}.")
    print("\n")


def solve_task5(ciphertext):
    """
    Решает Задание 5: Расшифровка сообщения, зашифрованного шифром Цезаря.
    """
    print("--- Задание 5: Взлом шифра Цезаря ---")
    print(f"Зашифрованное сообщение: {ciphertext}")

    alphabet = "абвгдежзийклмнопрстуфхцчшщъыьэюя"
    m = len(alphabet)

    print("Попытки расшифровки с разными ключами (K):\n")

    # Перебираем все возможные ключи от 1 до 31
    for k in range(1, m):
        decrypted_text = ""
        for char in ciphertext:
            if char in alphabet:
                char_index = alphabet.find(char)
                # Формула расшифровки: P = (C - k) mod m
                decrypted_index = (char_index - k + m) % m
                decrypted_text += alphabet[decrypted_index]
            else:
                decrypted_text += char  # Сохраняем пробелы и другие символы

        print(f"K = {k:2}: {decrypted_text}")

    print("\nВизуально определите, какой из вариантов является осмысленным текстом, чтобы найти правильный ключ.")
    print(
        "\nОтвет: Осмысленное сообщение получается при K=11: 'шифрование является процессом превращения читаемой информации в нечитаемый шифр'.\n")


# --- ОСНОВНОЙ БЛОК ---
if __name__ == "__main__":
    # --- Данные для варианта 1 ---

    # Задание 1.1
    p1, g1, a1, b1 = 23, 3, 4, 5
    solve_task1(p1, g1, a1, b1)

    # Задание 2.1
    p2, g2, a2, K2 = 7, 3, 4, 2
    solve_task2(p2, g2, a2, K2)

    # Задание 3.1
    fio = "Ушаков Александр Алексеевич"
    solve_task3(fio)

    # Задание 4.1
    # a, b, c - число букв в Фамилии, Имени и Отчестве
    # Ушаков (6), Александр (9), Алексеевич (10)
    a4, b4, c4 = 6, 9, 10
    solve_task4(a4, b4, c4)

    # Задание 5.1
    ciphertext5 = "ыйптжйыйходг рчифтхца хцтмц сйрстзтэт мпм жтжхй смыйзт сй хцтмц"
    solve_task5(ciphertext5)