Конечно! Давайте разберём каждое задание максимально подробно, чтобы вы чувствовали себя уверенно на защите лабораторной работы.

Я объясню теоретическую основу каждого шифра, шаги решения согласно вашим данным и как именно код реализует эти шаги.

### **Общие приготовления (для всех заданий)**

Прежде чем начать, код выполняет несколько подготовительных шагов:

1.  **Алфавит (`ALPHABET`):** Мы определяем алфавит, который будет использоваться. В методичке указан алфавит из 29 букв, где буква `я` стоит на первом месте и соответствует цифре 0. Буквы `ё`, `й`, `щ`, `ь` исключены, а их аналоги (`е`, `и`, `ш`, `ъ`) используются вместо них. Это наш числовой базис, или **модуль**, равный 29. Любая математическая операция будет выполняться по `mod 29`, что означает, что мы всегда будем брать остаток от деления на 29, чтобы результат оставался в пределах нашего алфавита (от 0 до 28).
2.  **Словари-преобразователи (`CHAR_TO_NUM`, `NUM_TO_CHAR`):** Создаются два словаря для удобства: один переводит букву в её порядковый номер в алфавите, а другой — номер обратно в букву.
3.  **Персональные данные:** Ваши ФИО и вариант (`16`) подставляются в переменные.
4.  **Формирование сообщения (`FULL_NAME`):** Ваше ФИО (`УшаковАлександрАлексеевич`) объединяется в одну строку, приводится к нижнему регистру и "нормализуется" — буквы `ё` и `й` заменяются на `е` и `и`, чтобы соответствовать нашему алфавиту.

---

### **Задание 1: Аффинный шифр**

**Цель:** Зашифровать первые 3 буквы вашего ФИО (`уша`) с помощью аффинного шифра.

**Теоретическая основа:**
Аффинный шифр — это простой шифр замены. Каждая буква исходного текста (`x`) заменяется на другую букву (`y`) по математической формуле:
`y = (a * x + b) mod m`

*   `x` — номер исходной буквы.
*   `y` — номер зашифрованной буквы.
*   `a` и `b` — это ключ шифрования.
*   `m` — размер алфавита (у нас `m = 29`).

**Шаги решения:**

1.  **Подготовка данных:**
    *   **Сообщение:** Первые 3 буквы от `ушаковалександралексеевич` — это `уша`.
    *   **Ключ `a`:** По заданию `a = i + 5`, где `i` — номер варианта. Ваш вариант `i = 16`.
        *   `a = 16 + 5 = 21`.
    *   **Ключ `b`:** По заданию `b` — это обратный элемент к `a` по модулю 29 (обозначается `a⁻¹ mod 29`). Это такое число `b`, что `(a * b) mod 29 = 1`.
        *   Нам нужно найти `21⁻¹ mod 29`. В методичке на странице 7 есть "Таблица обратных элементов в Z₂₉". Если посмотреть в этой таблице, мы увидим, что для числа 21 обратным является 18.
        *   Проверка: `(21 * 18) mod 29 = 378 mod 29 = 1`. Верно.
        *   Итак, `b = 18`.

2.  **Процесс шифрования (на примере буквы 'у'):**
    *   **Шаг 1:** Находим числовой эквивалент буквы 'у'. `CHAR_TO_NUM['у']` → `20`. Значит, `x = 20`.
    *   **Шаг 2:** Подставляем всё в формулу: `y = (a * x + b) mod 29`.
        *   `y = (21 * 20 + 18) mod 29`
        *   `y = (420 + 18) mod 29`
        *   `y = 438 mod 29`
    *   **Шаг 3:** Вычисляем остаток от деления 438 на 29. `438 / 29 = 15` с остатком `3`. Значит, `y = 3`.
    *   **Шаг 4:** Преобразуем число `3` обратно в букву. `NUM_TO_CHAR[3]` → `г`.
    *   Таким же образом шифруются 'ш' (25) и 'а' (1), в результате чего получается `гюя`.

**Реализация в коде:**
Цикл `for char in message:` проходит по каждой букве сообщения. Внутри него:
*   `x = CHAR_TO_NUM[char]` — получаем номер буквы.
*   `y = (a * x + b) % MOD` — вычисляем номер новой буквы (оператор `%` в Python — это и есть взятие остатка от деления).
*   `encrypted_message += NUM_TO_CHAR[y]` — добавляем зашифрованную букву к результату.

**Итог: `уша` → `гюя`**

---

### **Задание 2: Шифр Хилла**

**Цель:** Зашифровать те же 3 буквы (`уша`) с помощью шифра Хилла.

**Теоретическая основа:**
Шифр Хилла — это полиграммный шифр, который шифрует сразу блок из нескольких букв. Он использует линейную алгебру.
*   Блок исходного текста представляется как вектор-столбец `P`.
*   Ключом является квадратная матрица `K`.
*   Процесс шифрования — это умножение матрицы ключа на вектор текста: `C = K * P mod m`.
*   `C` — это результирующий вектор-столбец с номерами зашифрованных букв.

**Шаги решения:**

1.  **Подготовка данных:**
    *   **Сообщение:** `уша`.
    *   **Ключ-матрица `K`:** В задании дана матрица, в которой один элемент зависит от варианта `i`.
        ```
        1  2  3
        0  4  5
        0  0  i+3
        ```
        Подставляем ваш вариант `i = 16`:
        ```
        K = [[1, 2, 3],
             [0, 4, 5],
             [0, 0, 19]]
        ```
2.  **Процесс шифрования:**
    *   **Шаг 1:** Преобразуем сообщение `уша` в числовой вектор `P`:
        *   `у` → 20, `ш` → 25, `а` → 1.
        *   `P = [20, 25, 1]`
    *   **Шаг 2:** Умножаем матрицу `K` на вектор `P`:
        ```
        [1, 2, 3]   [20]   [1*20 + 2*25 + 3*1]   [20 + 50 + 3]   [73]
        [0, 4, 5] * [25] = [0*20 + 4*25 + 5*1] = [ 0 + 100 + 5] = [105]
        [0, 0, 19]  [ 1]   [0*20 + 0*25 + 19*1]  [ 0 +  0 + 19]   [19]
        ```
    *   **Шаг 3:** Берём остаток от деления на 29 для каждого элемента полученного вектора:
        *   `73 mod 29 = 15`
        *   `105 mod 29 = 18`
        *   `19 mod 29 = 19`
        *   Результирующий вектор `C = [15, 18, 19]`.
    *   **Шаг 4:** Преобразуем числа из вектора `C` обратно в буквы:
        *   `15` → `п`, `18` → `т`, `19` → `з`.
        *   Получаем `птз`. *Примечание: в первоначальном выводе была ошибка, я пересчитал значения для точности.*

**Реализация в коде:**
*   Для работы с матрицами используется библиотека `NumPy`.
*   `key_matrix = np.array(...)` — создаёт матрицу `K`.
*   `message_vector = np.array(...)` — создаёт вектор `P`.
*   `encrypted_vector = (key_matrix @ message_vector) % MOD` — самая важная строка. Оператор `@` в NumPy — это матричное умножение. `% MOD` применяется сразу ко всем элементам результата.
*   `"".join(...)` — собирает буквы из числового вектора в итоговую строку.

**Итог: `уша` → `птз`**

---

### **Задание 3: Шифр «Сумма оцифровок»**

**Цель:** Зашифровать первые 4 буквы ФИО (`ушак`) ключом, который является именем вашего отца (`алексей`).

**Теоретическая основа:**
Это разновидность полиалфавитного шифра, очень похожая на шифр Виженера. Каждая буква сообщения складывается с соответствующей буквой ключа. Если ключ короче сообщения, он циклически повторяется.
Формула: `Cᵢ = (Pᵢ + Kᵢ) mod m`
*   `Cᵢ` — i-я буква шифротекста.
*   `Pᵢ` — i-я буква исходного текста.
*   `Kᵢ` — i-я буква ключа.

**Шаги решения:**

1.  **Подготовка данных:**
    *   **Сообщение:** `ушак`.
    *   **Ключ:** `алексей`. Так как сообщение имеет длину 4, мы используем только первые 4 буквы ключа: `алек`.
2.  **Процесс шифрования (побуквенно):**
    *   **1-я буква:** `у` (20) + `а` (1) = 21. `21 mod 29 = 21` → `ф`.
    *   **2-я буква:** `ш` (25) + `л` (11) = 36. `36 mod 29 = 7` → `ж`.
    *   **3-я буква:** `а` (1) + `е` (6) = 7. `7 mod 29 = 7` → `ж`.
    *   **4-я буква:** `к` (10) + `с` (17) = 27. `27 mod 29 = 27` → `э`.
    *   Получаем `фжжэ`.

**Реализация в коде:**
*   `key = key[:len(message)]` — ключ обрезается до длины сообщения.
*   Цикл `for i in range(len(message)):` проходит по индексам от 0 до 3.
*   `message_num = CHAR_TO_NUM[message[i]]` — получаем номер буквы сообщения.
*   `key_num = CHAR_TO_NUM[key[i]]` — получаем номер буквы ключа.
*   `encrypted_num = (message_num + key_num) % MOD` — складываем их по модулю 29.
*   Результат добавляется к итоговой строке.

**Итог: `ушак` → `фжжэ`**

---

### **Задание 4: Шифр перестановкой**

**Цель:** Зашифровать первые 4 буквы ФИО (`ушак`), используя перестановочный шифр.

**Теоретическая основа:**
Шифр перестановки (или транзиционный шифр) не меняет сами буквы, а лишь перемешивает их внутри блока по определённому правилу (ключу-перестановке).

**Шаги решения:**

1.  **Подготовка данных:**
    *   **Сообщение:** `ушак`.
    *   **Перестановка:** `(1 3 5)(2 4 6)`. Это "циклическая нотация".
        *   `(1 3 5)` означает: элемент с позиции 1 идёт на позицию 3, с 3 — на 5, а с 5 — обратно на 1.
        *   `(2 4 6)` означает: элемент с 2 идёт на 4, с 4 — на 6, а с 6 — на 2.
    *   **Блок:** Длина перестановки — 6, значит, мы работаем с блоками по 6 символов.
    *   **Дополнение:** Наше сообщение `ушак` (4 символа) короче блока. Мы должны дополнить его до 6 символов. В коде для этого используется буква `а`.
        *   Сообщение для шифрования: `ушакаа`.

2.  **Процесс шифрования:**
    *   Правило шифрования, как указано в методичке (стр. 12): "На i-е место ставим τᵢ-ю букву исходного блока". Это означает, что новая строка формируется путем взятия букв из старой строки в порядке, заданном перестановкой.
    *   Исходный блок:
        `у ш а к а а`
        `1 2 3 4 5 6` (позиции)
    *   Формируем новый блок:
        *   На 1-ю позицию ставим букву со старой 3-й позиции (`а`).
        *   На 2-ю позицию ставим букву со старой 4-й позиции (`к`).
        *   На 3-ю позицию ставим букву со старой 5-й позиции (`а`).
        *   На 4-ю позицию ставим букву со старой 6-й позиции (`а`).
        *   На 5-ю позицию ставим букву со старой 1-й позиции (`у`).
        *   На 6-ю позицию ставим букву со старой 2-й позиции (`ш`).
    *   Результат: `акауаш`.

**Реализация в коде:**
*   `padded_message = message.ljust(block_size, padding_char)` — дополняет строку справа до 6 символов буквой 'а'.
*   `perm_map = {1: 3, 2: 4, 3: 5, 4: 6, 5: 1, 6: 2}` — словарь, который представляет нашу перестановку. Ключ — это новая позиция, значение — старая позиция, откуда брать букву.
*   `encrypted_list = [''] * block_size` — создаётся пустой список для результата.
*   Цикл `for i in range(1, block_size + 1):` перебирает позиции с 1 по 6.
*   `source_index = perm_map[i] - 1` — находим, из какой позиции *старой* строки взять букву ( `-1` нужен, так как в Python индексация с 0).
*   `dest_index = i - 1` — определяем, в какую позицию *новой* строки её положить.
*   `encrypted_list[dest_index] = padded_message[source_index]` — выполняется перестановка.

**Итог: `ушак` → `акауаш`**